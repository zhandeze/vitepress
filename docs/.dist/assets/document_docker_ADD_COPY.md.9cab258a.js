import{_ as l,o as s,c as a,Q as e}from"./chunks/framework.bb8e4904.js";const E=JSON.parse('{"title":"Dockerfile 中 COPY 和 ADD 命令的区别","description":"","frontmatter":{"title":"Dockerfile 中 COPY 和 ADD 命令的区别","isTimeLine":true,"date":"2022-04-13T16:52:01.000Z"},"headers":[],"relativePath":"document/docker/ADD_COPY.md","filePath":"document/docker/ADD_COPY.md"}'),o={name:"document/docker/ADD_COPY.md"},t=e('<h3 id="简介" tabindex="-1">简介： <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介：&quot;">​</a></h3><ul><li><p>创建 Dockerfile 时，通常需要将文件从主机系统传输到 Docker 映像中。这些可能是我们的应用程序在运行时需要的属性文件、本机库或其他静态内容。</p></li><li><p>Dockerfile 规范提供了两种将文件从源系统复制到映像中的方法：COPY 和 ADD 指令。</p></li><li><p>在本文中，我们将研究它们之间的区别以及何时使用它们是有意义的。</p></li><li><p>有时你会看到在 Dockerfile 中使用了 COPY 或 ADD，但 99% 的时间你应该使用 COPY。这是为什么？</p></li><li><p>COPY和ADD都是用于类似目的的 Dockerfile 指令。它们允许您将文件从特定位置复制到 Docker 映像中。</p></li><li><p>COPY接受 src 和目标。它只允许您将本地或目录中的主机（构建 Docker 映像的机器）复制到 Docker 映像本身。</p></li></ul><div class="language-cmd vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">COPY </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">src</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">dest</span><span style="color:#F97583;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">COPY </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">src</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">dest</span><span style="color:#D73A49;">&gt;</span></span></code></pre></div><ul><li>ADD 也允许您这样做，但它还支持其他 2 个来源。首先，您可以使用 URL 而不是本地文件/目录。其次，您可以将 tar 从源目录提取到目标。</li></ul><div class="language-cmd vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#79B8FF;">ADD</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">src</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">dest</span><span style="color:#F97583;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#005CC5;">ADD</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">src</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">dest</span><span style="color:#D73A49;">&gt;</span></span></code></pre></div><ul><li>在大多数情况下，如果您使用的是 URL，您会下载一个 zip 文件，然后使用RUN命令将其解压缩。但是，您也可以在这里使用RUN 和curl而不是- ADD ，因此您可以将所有内容链接到 1 个RUN命令中以制作更小的 Docker 映像。ADD</li><li>的一个有效用例是当您想要将本地 tar 文件提取到 Docker 映像中的特定目录中时。这正是 Alpine 映像对ADD rootfs.tar.gz / 所做的。如果要将本地文件复制到 Docker 映像，请始终使用COPY，因为它更明确。</li><li></li><li>虽然功能相似，但 ADD 指令在两个方面更强大：</li><li></li><li>它可以处理远程 URL</li><li>它还可以自动提取 tar 文件。</li><li>让我们更仔细地看看这些。</li><li>首先，ADD 指令可以接受一个远程 URL 作为其源参数。另一方面，COPY 指令只能接受本地文件。</li><li>请注意，使用 ADD 获取远程文件和复制通常并不理想。</li><li>这是因为该文件会增加整体 Docker Image 的大小。相反，我们应该使用curl或wget来获取远程文件并在不再需要时删除它们。</li><li>其次，ADD 指令会自动将 tar 文件展开到镜像文件系统中。虽然这可以减少构建映像所需的 Dockerfile 步骤的数量，但可能并非在所有情况下都- 需要。|</li><li>请注意，仅当源文件在主机系统本地时才会发生自动扩展。</li><li></li><li>何时使用 ADD 或 COPY ：</li><li>根据 Dockerfile 最佳实践指南，我们应该始终更喜欢 COPY 而不是 ADD，除非我们特别需要 ADD 的两个附加功能之一。</li><li>如上所述，使用 ADD 命令会自动扩展 tar 文件和某些压缩格式，这可能会导致意外文件被写入图像中的文件系统。</li></ul><h3 id="结论" tabindex="-1">结论： <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论：&quot;">​</a></h3><p>在本文中，您已经了解了将文件复制到 Docker 映像中的两种主要方法：添加和复制。虽然功能相似，但在大多数情况下首选 COPY 指令。这是因为 ADD 指令提供了应谨慎使用且仅在需要时才使用的附加功能。</p>',8),p=[t];function n(c,i,r,D,d,y){return s(),a("div",null,p)}const k=l(o,[["render",n]]);export{E as __pageData,k as default};
